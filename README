Interfejs graficzny
 
Rysunek 2.1 Główne okno programu KLab.
Główne okno programu przedstawione zostało na rysunku 2.1. Składa się ono z następujących elementów:
	Lista skryptów i funkcji („Current folder”) – lista plików skryptowych i funkcyjnych z rozszerzeniem „m” znajdujących się w aktualnym katalogu roboczym. Podwójne kliknięcie na wybraną pozycję powoduje otwarcie edytora skryptów.
	Konsola („Console”) – wyświetla wyniki obliczeń oraz ewentualne błędy w przypadku wprowadzenia do programu niepoprawnych danych.
	Linia poleceń („Command Line”) - pole tekstowe służące do wprowadzania poleceń. 
	Lista zmiennych („Workspace”) – wyświetla listę zmiennych znajdujących się w głównej przestrzeni roboczej programu, wraz z krótkimi informacjami o nich, tj. wartość lub wymiary, typ, minimalny i maksymalny element. Podwójne kliknięcie na nazwie zmiennej powoduje otwarcie edytora zmiennych.
	Historia poleceń („Command History”). Podwójne kliknięcie na wybrany element z listy powoduje dodanie polecenia do linii poleceń.
	Menu z przyciskami służącymi do: utworzenia nowego skryptu lub funkcji, przerwania długo wykonujących się obliczeń oraz zmiany katalogu roboczego.
	Rozwijana lista z historią wybieranych katalogów roboczych.
Edytor skryptów i funkcji
KLab został wyposażony w wbudowany edytor skryptów i funkcji (rys. 2.2).  Każdy plik jest otwarty w osobnej karcie. Do uruchomiania wykonywania skryptu służy odpowiednia pozycja w menu („Run script”) lub klawisz F5. Przed rozpoczęciem wykonywania zmiany wprowadzone do pliku zostają automatycznie zapisane na dysk. Edytor obsługuje kolorowanie składni języka. Słowa kluczowe są oznaczone na niebiesko, a komentarze na zielono. Dostępne są skróty klawiaturowe: nowy skrypt (Ctrl+N), szybki zapis (Ctrl+S) oraz otwieranie istniejącego skryptu (Ctrl+O).
 
Rysunek 2.2. Wbudowany edytor skryptów i funkcji.
Edytor zmiennych
Aby uruchomić graficzny edytor zmiennych (rys. 2.3), należy podwójnie kliknąć lewym przyciskiem myszy na nazwie wybranej zmiennej. Do komórek można wprowadzać dowolne wyrażenie, którego wynikiem jest wartość skalarna. Wymiary macierzy są automatycznie rozszerzane, jeżeli zachodzi taka potrzeba, a brakujące komórki są wypełniane wartością 0. Stan edytora jest odświeżany, po zakończeniu obliczeń, w przypadku gdy dana zmienna została edytowana, np. w uruchomionym skrypcie. Automatycznie zaktualizowana zostaje tylko aktualnie wyświetlana zmienna (zakładka w edytorze), a pozostałe są odświeżane, jedynie w przypadku gdy zachodzi taka potrzeba. 
 
Rysunek 2.3. Graficzny edytor zmiennych w stworzonym programie.
Wprowadzanie poleceń
Wprowadzanie poleceń do programu możliwe jest za pomocą pola tekstowego o nazwie „Command Line”. Program jest gotowy do przyjęcia komend, gdy wyświetlany jest tekst „Enter command here”, tak jak na rysunku 2.4. Jeżeli program wykonuje obliczenia, wyświetlana jest stosowna informacja (rys. 2.5), a wpisywanie poleceń jest zablokowane.
 
Rysunek 2.4. Pole tekstowe służące do wprowadzania poleceń do programu KLab.
 
Rysunek 2.5. Informacja o wykonywania obliczeń w stworzonym programie.
Przerwanie długo wykonujących się obliczeń jest możliwe za pomocą kombinacji klawiszy Ctrl+C lub odpowiedniego przycisku w pasku menu. Nie jest możliwe przerwanie wykonywania wbudowanych operacji, np. wbudowanej funkcji służącej do liczenia wyznacznika macierzy. Przełączanie pomiędzy ostatnio wydawanymi instrukcjami, jest możliwe za pomocą strzałek góra/dół na klawiaturze.
Zasady wprowadzania komend są podobne do tych w programach MATLAB i Octave. Domyślnie wynik wyrażenia przypisywany jest do zmiennej ans. Aby nie wyświetlać wyniku instrukcji, należy zakończyć ją średnikiem. Czyszczenie zawartości konsoli możliwe jest za pomocą komendy clc. Polecenia można oddzielać znakiem nowej linii, przecinkiem lub średnikiem. Aby wskazać, że wyrażenie będzie kontynuowane w następnej linii, należy użyć znaku trzykropka. Jakiekolwiek napisy, występujące po nim do końca linii, są traktowane jako komentarz. Przykładowe polecenia przedstawia poniższy listing (2.1).
>> 2+2

ans=
4

>> a=2+2,3,4;

a=
4

ans=
3

>> b=3 + ... to jest komentarz
10

b=
13

Listing 2.1. Podstawowe sposoby wprowadzania poleceń w stworzonym programie.
Zmienne
Program umożliwia tworzenie zmiennych bez konieczności wcześniejszego ich deklarowania. Nazwa zmiennej musi rozpoczynać się od litery i może składać się z dowolnego ciągu liter, cyfr i znaków podkreślenia. Rozróżniane są małe i duże litery. Niektóre nazwy, np. for, są zarezerwowane dla słów kluczowych i nie możliwe jest utworzenie zmiennej o tej nazwie.
Aby utworzyć nową zmienną należy użyć operatora przypisania =, w postaci: identyfikator = wyrażenie. Wartość wyrażenia występującego po znaku =, zostanie zapisana w przestrzeni programu pod nazwą określoną przez „identyfikator”. Od tej pory będzie możliwe odwołania się do tej wartości, za pomocą stworzonego indetyfikatora.
Wywoływanie funkcji
Sposób wywoływania funkcji w stworzonym programie jest zgodny ze składnią języka MATLAB. Wywołanie może mieć jedną z postaci przedstawionych w poniższym listingu (2.3), w którym: fun to nazwa wywoływanej funkcji; out, out1, outN to parametry wyjściowe; arg1, argN to argumenty wejściowe.
fun( arg1, arg2, ... , argN )        %lub
out = fun ( arg1, arg2, ... , argN ) %lub
[out1 , out2 , ... , outN ] = fun( arg1, arg2, ... , argN)
Listing 2.2. Ogólna postaci wywoływania funkcji w stworzonym programie.
Listę parametrów wyjściowych funkcji, czyli zmiennych do których zostaną przypisane wartości wynikowe wywołania, należy umieścić pomiędzy nawiasami kwadratowymi, a poszczególne elementy tejże listy oddzielić przecinkami lub spacjami. W przypadku wywołania metody bez parametrów wyjściowych, do zmiennej ans przypisana zostanie pierwsza ze zwracanych wartości. Parametrem wyjściowym może być literał oznaczający nazwę zmiennej lub indeks  wskazujący na elementy istniejącej już macierzy.
Listę argumentów wejściowych funkcji, czyli wartości na podstawie których będą dokonywane obliczenia wewnątrz tej metody, należy umieścić pomiędzy nawiasami okrągłymi, występującymi po nazwie funkcji. Argumenty te muszą zostać oddzielone przecinkiem.
>> [m,n] = size( [1 3 -4 ; 3 2 1-9] )

m=
2     

n=
3     

Listing 2.3. Przykład wywołania funkcji size.
Konflikty nazw
Podczas pracy z programem, może wystąpić sytuacja, w której nazwa funkcji jest taka sama jak identyfikator zmiennej. Pomimo, że nazwy zmiennych mają pierwszeństwo przed nazwami funkcji, należy unikać takich sytuacji, gdyż może to prowadzić do nieprzewidzianych wyników. Przykładowo po utworzeniu zmiennej o nazwie size, nie będzie możliwe użycie metody o tej nazwie. 
Typy danych
Program umożliwia tworzenie wartości różnych typów, które zostały przedstawione poniżej (tabela 2.1). 
Tabela 2.1. Typy zmiennych obsługiwane przez program KLab.
Typ	Opis
double	Liczba zmiennoprzecinkowa podwójnej precyzji.
mpf_float	100 bitowa liczba zmiennoprzecinkowa.
matrix<double>	Macierz o elementach typu double.
matrix<mpf_float>	Macierz o elementach typu mpf_float.
string	Łańcuch tekstowy.

Wartości skalarne
Literał liczbowy powinien zawierać cześć całkowitą i opcjonalnie część po przecinku. Możliwy jest także zapis liczby w postaci wykładniczej. Liczba zespolona jest zakończona znakiem „i”. Przykładowe sposoby zapisu przedstawione zostały w listingu 2.1. Wartości skalarne mogą posiadać typ double lub mpf_float.
22
0.22e2
0.22e+2
2200e-2
56i
2e-4i
1i
mpf_float(4) % Tworzy skalar typu mpf_float
Listing 2.4. Sposoby zapisu liczby w KLab.
Macierze
Program umożliwia zapis danych w formie macierzy. Mogą one posiadać typ matrix<double> lub matrix<mpf_float> i składają się odpowiednio z elementów typu double lub mpf_float. Sposób tworzenia macierzy zostanie umówiony w dalszej części opracowania. Macierze o wymiarach 1x1 są traktowane tak samo jak wartości skalarne.
Łańcuchy tekstowe
Do tworzenia łańcuchów tekstowych używa się pojedynczych apostrofów (rys. 2.5). Aby umieścić ten w znak tekście, należy go dwukrotnie powtórzyć. W przeciwieństwie do środowiska Matlab i Octave zmienne tekstowe nie są traktowane jako macierze.
 
Rysunek 2.6. Przykład tworzenia łańcucha tekstowego w KLab.
Promocja typów
W przypadku, gdy dane działanie wykonywane jest na zmiennych o różnych typach, następuję automatyczna promocja typów. Przykładowo operacja dodawania wykonana na zmiennych typu mpf_float i double, zwróci wynik w postaci mpf_float (rys. 2.6). Priorytety typów numerycznych w kolejności rosnącej: double, mpf_float, matrix<double>, matrix<mpf_float>. Konwersja odbywa się zawsze do typu o większym priorytecie. Niemożliwa jest konwersja pomiędzy łańcuchem tekstowym, a wartością numeryczną. 
 
Rysunek 2.7. Automatyczna promocja typów w KLab.
Sposoby tworzenia macierzy
Użycie operatora []
Najprostszym sposobem na utworzenie nowej macierzy jest użycie operatora []. Jej elementy składowe należy otoczyć nawiasami kwadratowymi. Komórki w pojedynczym wierszu oddzielone są spacją lub przecinkiem, a poszczególne wiersze oddziela średnik lub znak nowej linii. Przykład tworzenia macierzy typu matrix<double> przedstawiony został na rysunku 2.6. W przypadku, gdy tworzona w ten sposób macierz, posiada nieregularny kształt (wiersze posiadają różną liczbę elementów), zostanie wyświetlony odpowiedni komunikat o błędzie, a tworzenie zostanie przerwane. Elementami składowymi mogą być dowolne wyrażenia, dające wynik w postaci wartości numerycznej, która posiada odpowiednie wymiary. Nie jest wymagane wcześniejsze deklarowanie rozmiarów tworzonej macierzy. Istnieje możliwość stworzenia pustej macierz.
 
Rysunek 2.8. Przykład tworzenia macierzy typu matrix<double> w programie KLab.
Automatyczne ustalanie typu tworzonej macierzy
	Typ tworzonej macierzy zależy od jej elementów składowych. Gdy typ o maksymalnym priorytecie to double lub matrix<double>, utworzona zostanie macierz typu matrix<double>, w innym wypadku wynikiem będzie matrix<mpf_float> (rys. 2.7). Zmienna C posiada typ matrix<double>, gdyż funkcja size(A) zwraca wektor wierszowy  typu matrix<double>. Typem zmiennej D jest matrix<mpf_float>, gdyż użyta została funkcja rzutowania  mpf_float. Macierz E jest typu matrix<mpf_float>, ponieważ spośród elementów składowych najwyższy priorytet posiada mpf_float.
 
Rysunek 2.9. Przykład automatycznego ustalania typu tworzonej macierzy w programie KLab.
Znak liczby podczas tworzenia macierzy
Podczas tworzenia zmiennych macierzowych, posiadających elementy ze znakiem, znak liczby powinien bezpośrednio poprzedzać jej wartość. W przeciwnym wypadku zostanie on rozpoznany przez interpreter, jako operator dodawania lub odejmowania (tabela 2.2).
Tabela 2.2. Porównanie różnic w interpretacji operatorów – i + podczas tworzenia macierzy i wartości skalarnych w programie KLab.
>> 3 -5 +10

ans=
8
	>> 3 - 5 + 10

ans=
8

>> [3 -5 +10]

ans=
3     	-5     	10     
	>> [3 - 5 + 10]

ans=
8     


Szybkie generowanie wektorów
Stworzony program umożliwia szybkie generowanie wektorów, używając do tego operatora dwukropka. Gdy operandem jest macierz, brany jest pod uwagę jedynie jej pierwszy element. Jeżeli wśród argumentów znajduje się macierz pusta lub liczba zespolona, stworzony zostanie pusty wektor. Podczas wykonywania tego wyrażenia, brana jest pod uwagę kolejność operatorów. Operandami mogą być dowolne wyrażenie arytmetyczne lub wywołanie funkcji. Przykład 2.1 przedstawia sposoby użycia tego operatora.
Zapis i:j tworzy wektor postaci [i, i+1, i+2, … ,j], gdzie i jest wartością pierwszego elementu wektora, a j wartością ostatniego elementu. Domyślnie różnica pomiędzy kolejnymi elementami ciągu jest równa 1. W przypadku gdy i<j, stworzony zostaje pusty wektor. 
Zapis i:k:j definiuje wektor [i, i+k, i+2*k, …, j], gdzie: i jest wartością początkową wektora; k różnicą pomiędzy kolejnymi elementami; j wartością końcową. Różnica może być rzeczywistą liczbą dodatnią lub ujemną. Gdy wartość kroku pomiędzy elementami jest równa zero, wygenerowany zostanie wektor pusty.
Przykład 2.1. Generowanie wektorów w stworzonym programie.
>> A=1:6

A=
1     	2     	3     	4     	5     	6     

>> A=6:1

A=
[ ] 1x0
>> A=1:[6 10]

A=
1     	2     	3     	4     	5     	6     

>> A=1:3i

A=
[ ] 1x0
>> A=1:0.13+2*0.035:2

A=
1     	1.2     	1.4     	1.6     	1.8     	2     

>> A = 1 : size(A') : 10

A=
1     	7     

>> A = 10 : -1 : 5

A=
10     	9     	8     	7     	6     	5     

>> A=1:[]:5

A=
[ ] 1x0

Konkatenacja macierzy
Stworzony program umożliwia łączenie jednej lub więcej macierzy. Służy do tego omawiany wcześniej operator []. Wyrażenie [A B] łączy poziomo zmienne macierzowe A i B. Natomiast wyrażenie [A ; B] łączy te zmienne pionowo. Łączenie poziome oznacza, że łączone są odpowiadające sobie wiersze macierzy, pionowe łączy odpowiadające sobie kolumny. Wynikowa macierz musi posiadać regularny kształt. Łączenie pionowe i poziome przedstawione zostało na przykładzie 2.2.
Przykład 2.2. Konkatenacja macierzy w stworzonym programie.
>> A=[1;2;3];

>> B=[A [4;5;6]]

B=
1     	4     
2     	5     
3     	6     

>> B=[A [4;5]]
Dimensions of matrices being concatenated are not consistent.
>> C=[A ; [4;5]]

C=
1     
2     
3     
4     
5     


Tworzenie macierzy za pomocą wbudowanych funkcji
KLab oferuje wbudowane funkcje służące do szybkiego tworzenia macierzy. Należą do nich:
	rand – generuje macierz o podanych wymiarach, wypełnioną losowymi dodatnimi liczbami całkowitymi.
	eye – generuje macierz, z wartością 1 na głównej przekątnej i pozostałymi elementami równymi 0.
	ones – generuje macierz o podanych wymiarach, wypełnioną jedynkami.
	zeros – generuje macierz wypełnioną zerami.
Wszystkie z wyżej wymienionych funkcji, przyjmują jeden lub dwa argumenty. W przypadku pojedynczego argumentu, wygenerowana zostanie macierz kwadratowa o podanym stopniu. W przypadku dwóch argumentów, pierwszy z nich oznacza liczbę wierszy, a drugi liczbę kolumn. Przekazywane parametry muszą być liczbami naturalnymi, w przeciwnym wypadku wygenerowany zostanie odpowiedni błąd. Przykład użycia funkcji rand i eye, przedstawiony został na rysunkach 2.8 i 2.9.
 
Rysunek 2.10. Przykład użycia funkcji rand w programie KLab.	 
Rysunek 2.11. Przykład użycia funkcji eye w programie KLab.
Indeksowanie macierzy
Program umożliwia dostęp do wybranych elementów macierzy. Możliwy jest wybór jedynie wybranych elementów lub całych wierszy i kolumn.
Dostęp do pojedynczych komórek
Aby wskazać na konkretny element macierzy, należy określić jego numer wiersza i kolumny. Odwołanie musi mieć następującą postać: A(i,j). A oznacza nazwę macierzy, i – numer wiersza, j – numer kolumny. Argumentami odwołania, muszą być dodatnie liczby całkowite bez części zespolonej.
	Poniżej przedstawiony został przykład (listing 2.6) odwołania się do elementów macierzy A. Wiersze i kolumny są zawsze numerowane od 1. W przypadku, gdy indeks przekracza wymiary macierzy lub nie jest całkowitą liczbą dodatnią, wyświetlany jest stosowny komunikat o błędzie.
>> A=create(4,4)

A=
1     	5     	9     	13     
2     	6     	10     	14     
3     	7     	11     	15     
4     	8     	12     	16     

>> A(2,3)

ans=
10     

>> A(2*4,3)
Index exceeds matrix dimensions.
>> A(2i,3)
Subscript indices must either be real positive integers or logicals.
Listing 2.5. Przykład dostępu do pojedynczych elementów macierzy.
Dostęp do wielu elementów jednocześnie
Stworzony program umożliwia dostęp do wielu elementów macierzy jednocześnie, przekazując jako indeks macierz z numerami wybranych kolumn lub wierszy. Przykładowe polecenia przedstawione zostały poniżej (listing 2.7).
>> A=create(4,4)

A=
1     	5     	9     	13     
2     	6     	10     	14     
3     	7     	11     	15     
4     	8     	12     	16     

>> A(1,2:4)

ans=
5     	9     	13     

>> A([1,4],[2:4 1])

ans=
5     	9     	13     	1     
8     	12     	16     	4     

Listing 2.6. Przykład dostępu do wielu elementów macierzy jednocześnie.
	Pierwsze polecenie z powyższego przykładu tworzy nową macierz A. Następnie wybierany jest pierwszy wiersz oraz kolumny od drugiej do czwartej. Istnieje także możliwość zamiany kolejności wybieranych komórek, co ilustruje polecenie ostatnie.
Wybór całych wierszy lub kolumn
Aplikacja oferuje możliwość szybkiego wyboru całych wierszy lub kolumn, za pomocą operatora :.  Przykładowo, aby wybrać całą j-tą kolumnę macierzy A, należy użyć polecenia A(:,j), a do wyboru i-tego wiersza służy  A(i,:).
>> A=create(2,7)

A=
1     	3     	5     	7     	9     	11     	13     
2     	4     	6     	8     	10     	12     	14     

>> A(2,:)

ans=
2     	4     	6     	8     	10     	12     	14     

>> A(:,1:2:7)

ans=
1     	5     	9     	13     
2     	6     	10     	14     

Listing 2.7. Przykład wyboru całych wierszy i kolumn.
Powyższy listing (2.7) przedstawia przykład wyboru drugiego wiersza macierzy A (drugie polecenie) oraz wyboru co drugiej kolumny (polecenie trzecie).
Słowo kluczowe END
Aby wskazać ostatni wiersz lub kolumnę macierzy należy użyć słowa kluczowego end. Pozwala to na łatwy wybór komórek bez wiedzy o rozmiarach macierzy. Przykład użycia słowa kluczowego end przedstawia poniższy listing (2.8).
>> A=create(3,10)

A=
1     	4     	7     	10     	13     	16     	19     	22     	25     	28     
2     	5     	8     	11     	14     	17     	20     	23     	26     	29     
3     	6     	9     	12     	15     	18     	21     	24     	27     	30     

>> A(end,end-1)

ans=
27     

>> A(1:2,1:3:end)

ans=
1     	10     	19     	28     
2     	11     	20     	29     

Listing 2.8 Przykład użycia słowa kluczowego end do dostępu do elementów macierzy.
Indeksowanie liniowe
Stworzony program wspiera indeksowanie liniowe. W przypadku odwołania do elementów macierzy za pomocą tylko jednego indeksu, jest ona traktowana jako wektor kolumnowy. Przykład indeksowania liniowego przedstawia poniższy listing (2.9).
>> A=create(3,3)

A=
1     	4     	7     
2     	5     	8     
3     	6     	9     

>> A(4)

ans=
4     

>> A(:)

ans=
1     
2     
3     
4     
5     
6     
7     
8     
9     

Listing 2.9 Przykład indeksowania liniowego macierzy w stworzonym programie.
Modyfikacja wybranych elementów
Program umożliwia również modyfikacje wybranych elementów macierzy za pomocą operatora przypisania. Przykład modyfikacji pojedynczych komórek przedstawiony został w poniższym listingu.
>> A=(1:4)*10

A=
10     	20     	30     	40     

>> A(1)=A(4)

A=
40     	20     	30     	40     

>> [A(1,1) A(1,4)]=size(A)

A=
1     	20     	30     	4     

Listing 2.10 Przykład modyfikacji pojedynczych komórek macierzy.
	Możliwe jest również automatyczne rozszerzania wymiarów macierzy, jeżeli indeks wybranego elementu przekroczy rozmiary zmiennej (listing 2.11). Brakujące komórki wypełniane są wartością 0. Rozszerzanie macierzy nie jest możliwe w przypadku indeksowania liniowego.
>> A=1:4

A=
1     	2     	3     	4     

>> A(2,5) = 4^4

A=
1     	2     	3     	4     	0     
0     	0     	0     	0     	256     

>> A(15)=4
Index exceeds matrix dimensions.
Listing 2.11 Automatyczne rozszerzenie wymiarów macierzy.
Poza modyfikacją pojedynczych elementów program oferuje, edycję wielu komórek jednocześnie, co przedstawia poniższy przykład (listing 2.12).
>> B=[]

B=
[ ] 0x0
>> B(2:3,:)=[1:5 ; 6:10]

B=
0     	0     	0     	0     	0     
1     	2     	3     	4     	5     
6     	7     	8     	9     	10     

>> B(1,1:2:end)=4

B=
4     	0     	4     	0     	4     
1     	2     	3     	4     	5     
6     	7     	8     	9     	10     
				
>> B(1,:)=1:10
Subscripted assignment dimension mismatch.
Listing 2.12. Przykład modyfikacji wielu komórek macierzy jednocześnie.
	Prawy argument operatora przypisania musi mieć takie same rozmiary, jak podmacierz składająca się z modyfikowanych komórek. W przeciwnym wypadku zostanie wyświetlony odpowiedni błąd, co przedstawia ostatnie polecenie z powyższego przykładu (listing 2.12).
Usuwanie kolumn i wierszy
Program umożliwia usuwanie z macierzy wybranych kolumn i wierszy poprzez przypisanie do nich pustej macierzy. Możliwe jest usuwanie jedynie całych wierszy i kolumn. Poniższy listing (2.13) przedstawia sposoby usuwania elementów  z macierzy.
>> A=create(4,4)

A=
1     	5     	9     	13     
2     	6     	10     	14     
3     	7     	11     	15     
4     	8     	12     	16     

>> A(1,1)=[]
Wrong data to matrix elements erase
>> A(1,1:4)=[]

A=
2     	6     	10     	14     
3     	7     	11     	15     
4     	8     	12     	16     

>> A([1 3],:)=[]

A=
3     	7     	11     	15     

Listing 2.13 Przykład usuwania wybranych wierszy i kolumn z macierzy.
Operatory
Stworzony program posiada zestaw operatorów: arytmetycznych, relacyjnych oraz logicznych. Podobnie jak w programach MATLAB i Octave rozróżnia się działania tablicowe i macierzowe.
Operatory matematyczne
Program posiada zestaw wbudowanych operatorów arytmetycznych, które zostały przedstawione w tabeli poniżej (2.3).
Tabela 2.3. Lista operatorów matematycznych oferowanych przez stworzony program.
Symbol	Działanie
A+B	Dodawanie.
A.+B	Dodawanie tablicowe.
+A	Unarny plus. Zwraca wartość A.
A-B	Odejmowanie.
A.-B	Odejmowanie tablicowe.
-A	Liczba przeciwna.
A*B	Mnożenie macierzy.
A.*B	Mnożenie tablicowe.
A/B	Dzielenie prawostronne.
A./B	Dzielenie tablicowe prawostronne.
A\B	Dzielenie lewostronne.
A.\B	Dzielenie tablicowe lewostronne.
A^B	Potęgowanie macierzowe.
A.^B	Potęgowanie tablicowe.
A’	Sprzężenie hermitowskie macierzy.
A.’	Transpozycja tablicowa.

Wynik dzielenia macierzowego prawostronnego A/B jest obliczany jako iloczyn macierzy A z macierzą odwrotną do B, gdy A i B nie jest wartością skalarną. W przeciwnym wypadku wykonywane jest dzielenie tablicowe A./B.
Zapis A\B=x spowoduje rozwiązanie układu równań liniowych A*x=B, jeżeli A i B nie jest wartością skalarną. W przeciwnym wypadku zostanie wykonane lewostronne dzielenie tablicowe A.\B.
>> A=[1 2 4 ; 3 2 1 ; 2 1 2]\[ 4 ; 2 ;10 ]

A=
5.33333     
-9.11111     
4.22222     

>> A*A'

ans=
28.4444     	-48.5926     	22.5185     
-48.5926     	83.0123     	-38.4691     
22.5185     	-38.4691     	17.8272     

>> A.*A

ans=
28.4444     
83.0123     
17.8272     

>> A*A
Error using * Matrix dimensions must agree
Listing 2.14. Przykład użycia operatorów arytmetycznych.
Operatory relacji
Dostępne w stworzonym programie operatory relacji, służące do porównywania wartości, zostały przedstawione w poniższej tabeli (2.4). W przypadku operatorów <, <=, >, >= porównywana jest jedynie część rzeczywista operandów.
Tabela 2.4. Lista operatorów relacji dostępnych w stworzonym programie.
Symbol	Operator relacji
A==B	A równe B.
A~=B	A różne od B.
A<B	A mniejsze od B.
A<=B	A mniejsze lub równe B.
A>B	A większe od B.
A>=B	A większe od B.
Operatory relacji porównują wartości skalarne lub macierze element po elemencie. Jeżeli relacja pomiędzy badanymi elementami jest spełniona, zwracana jest wartość 1 oznaczająca prawdę, w przeciwnym wypadku zwracana jest wartość 0 oznaczająca fałsz. Podobnie jak w przypadku operatorów tablicowych, operandy muszą mieć równe wymiary lub jeden z nich musi być wartością skalarną. Przykład użycia porównań przedstawiony został w poniższym listingu (2.6)
>> A=[1 4 3 ; 4 3 4 ; 4 3 3];

>> A <= [1 4 3; 2 3 4; 5 4 3]

ans=
1     	1     	1     
0     	1     	1     
0     	0     	1     

>> A == 4

ans=
0     	1     	0     
1     	0     	1     
1     	0     	0     

>> 1.42 < 2^-0.5

ans=
0

Listing 2.15. Przykład użycia operatorów relacji w stworzonym programie.
Operatory logiczne
Stworzony program oferuje możliwość obliczania operacji logicznych, przedstawionych w poniższej tabeli (2.5). Wyrażenie daje logiczny fałsz, jeżeli jego wynik jest równy 0. Wartość różna od zera oznacza prawdę.
Tabela 2.5. Operatory logiczne dostępne w stworzonym programie
Operator	Opis
wyrażenie1 | wyrażenie2	Dysjunkcja. Wykonywane jest zawsze wyrażenie1 i wyrażenie2.
wyrażenie1 & wyrażenie2	Koniunkcja. Wykonywane jest zawsze wyrażenie1 i wyrażenie2.
wyrażenie1 || wyrażenie2	Dysjunkcja. Drugie wyrażenie jest obliczane jedynie wtedy, gdy pierwsze daje wartość fałsz.
wyrażenie1 && wyrażenie2	Koniunkcja. Drugie wyrażenie jest obliczane jedynie wtedy, gdy pierwsze jest prawdziwe.
~wyrażenie	Negacja logiczna. Zamienia wartości równe 0 na 1, a różne od zera na 1.

W przypadku operatorów | , & oraz ~ operandem może być dowolna wartość skalarna lub macierz. Elementy macierzy są dopasowywane tak samo, jak w przypadku operatorów relacji. Poniższy listing (2.7) przedstawia przykład użycia wyżej wymienionych operatorów.
>> A=[0 3 2 ];

>> B=[0 1 0 ];

>> A | B

ans=
0     	1     	1     

>> A & B

ans=
0     	1     	0     

>> ~ans

ans=
1     	0     	1     

Listing 2.16. Przykład użycia operatorów | , & oraz ~.
Argumentami operatorów && i || muszą być wartości skalarne. W przeciwnym wypadku wygenerowany zostanie odpowiedni błąd. Wynik wyrażenia składającego się z tych operatorów jest obliczany, dopóki nie będzie znany jego ostateczny wynik. Przedstawione zostało to na poniższym przykładzie (listing 2.8).
>> 1 && rand(3,3)
Error in "&&" operator: Data must be convertible to logical scalar values.
>> 5-5 || 1 || d

ans=
1

>> 5-5 || 0 || d
Undefined variable or script 'd'.
>> 5-5 && 2+2 && d

ans=
0

>> 5-3 && 2+2 && d
Undefined variable or script 'd'.
Listing 2.17. Przykład użycia operatorów && i || w stworzonym programie.
Kolejność wykonywania i łączność operatorów
Podczas wykonywania wyrażeń, zachowywany jest priorytet operatorów, dzięki czemu zachowywana jest właściwa kolejność wykonywania działań. Poniższa lista przedstawia priorytety operatorów w kolejności malejącej:
	Nawiasy ().
	Transpozycja (.’), potęgowanie (.^), sprzężenie hermitowskie macierzy (^), potęgowanie macierzowe (^).
	Jednoargumentowy minus (-) i plus (+), negacja logiczna (~).
	Mnożenie (.*), dzielenie prawostronne(./), dzielenie lewostronne (.\), mnożenie macierzowe (*), mnożenie macierzowe prawostronne(/), mnożenie macierzowe lewostronne (\).
	Dodawanie (+), odejmowanie (-).
	Operator dwukropka (:).
	Mniejszy od (<), mniejszy lub równy (<=), większy od (>), większy lub równy (>=), równość (==), nierówność (~=).
	Koniunkcja tablicowa AND (&).
	Dysjunkcja tablicowa OR (|).
	Koniunkcja AND (&&).
	Dysjunkcja OR (||).
	Przypisanie (=).
Operator o większym priorytecie jest wykonywany przed operatorem o priorytecie mniejszym. Wszystkie operacje jednoargumentowe są prawostronnie  łączne, pozostałe z nich są lewostronnie  łączne. Operator przypisania nie posiada określonej łączności, gdyż nie może występować wielokrotnie w wyrażeniu.
>> 2+3*0.5^-2-10

ans=
4

>> (2+3)*0.5^-2-10

ans=
10

Listing 2.18. Przykład zachowania kolejności operatorów w stworzonym programie.
	Pierwsze z wyrażeń z powyższego przykładu (listing 2.9) jest równoważne z zapisem: ” 2+(3*(0.5^(-2)))-10”. Nawiasy mogą zostać użyte do zmiany domyślnej kolejności wykonywania operatorów, co przedstawia drugie wyrażenie z powyższego przykładu.
Wbudowane funkcje
Program posiada zestaw wbudowanych funkcji obliczeniowych, ułatwiających przeprowadzanie obliczeń. Dodatkowo cechują się one większą szybkością wykonywania, niż funkcje zewnętrzne zdefiniowane przez użytkownika. Wyniki niektórych funkcji może się różnić w zależności od liczby parametrów wyjściowych i argumentów wejściowych.
Podstawowe funkcje
Funkcja sqrt(A) oblicza pierwiastek kwadratowy z wartości A. W przypadku macierzy, pierwiastek jest obliczany dla każdego jej elementu.
Do rzutowania wartości na typ mpf_float, służy funkcja mpf_float(A).
Funkcje logarytmiczne
Do obliczania logarytmów służą funkcje: log, log2 oraz log10. Program umożliwia liczenie logarytmów z liczb ujemnych i zespolonych. W przypadku, gdy argumentem logarytmu jest macierz, funkcja logarytmiczna jest stosowana dla każdego jej elementu, a wynikiem jest macierz logarytmów.
Funkcja log(a,b) liczy poniższy logarytm (rów. 2.1) i zwraca wynik x. Podstawa a logarytmu musi być wartością skalarną.
	log_a⁡〖b=x〗,		
gdzie: a,b∈C ∧a∉{0,1}∧b≠0
	Funkcja log(a) liczy logarytm naturalny z a. Metoda log2(a) liczy logarytm o podstawie 2, a log10(a) logarytm dziesiętny. Przykład użycia funkcji logarytmicznych przedstawia poniższy listing (2.19)
>> log(-10)

ans=
2.30259+3.14159i

>> log(3,[3 9 27 81])

ans=
1     	2     	3     	4     

>> log(4i,2i)

ans=
0.781076+0.248061i

Listing 2.19 Przykład użycia funkcji logarytmicznych.
Funkcje trygonometryczne
Program posiada podstawowe funkcje trygonometryczne. Przedstawione one zostały w poniższej tabeli. Każda z tych funkcji przyjmuje pojedynczy argument i zwraca pojedynczy wynik. Argumentami tych funkcji mogą być wartości skalarne (również z częścią zespoloną) i macierze. Obliczenia przeprowadzane są w radianach.
Tabela 2.6 Funkcje trygonometryczne oferowane przez program.
Nazwa funkcji	Opis
sin	Funkcja sinus.
cos	Funkcja cosinus.
tan	Funkcja tangens.
cot	Funkcja cotangens.

Poniższy przykład przedstawia sposób działania funkcji trygonometrycznych (listing 2.20).
>> sin(3.14)

ans=
0.00159265

>> cos([0 3.14/2 3.14 3.14*2])

ans=
1     	0.000796327     	-0.999999     	0.999995     

>> tan(1+2i)

ans=
0.0338128+1.01479i

Listing 2.20 Przykład użycia funkcji trygonometrycznych.
Algebra liniowa
Sprzężenie zespolone
Do wyznaczania sprzężenia zespolonego służy funkcja conj(A), przedstawiona na poniższym przykładzie.
>> conj([3-2i 4+2i 10-3i])

ans=
3+2i     	4-2i     	10+3i     

Listing 2.21 Przykład użycia funkcji conj.
Wyznacznik macierzy
Liczenie wyznacznika macierzy możliwe jest za pomocą funkcji det (listing 2.21), przyjmującej pojedynczy argument i zwracającej wartość obliczonego wyznacznika.
>> a = det([1 3 2; 3 2 2 ; 3 2 1])

a=
7     

Listing 2.22. Przykład użycia funkcji det.
Macierz odwrotna
Wyznaczanie macierzy odwrotnej jest możliwe za pomocą funkcji inv(A). Jako wynik zwraca ona wyznaczoną macierz odwrotną (listing 2.22).
>> a = inv([1 3 2; 3 2 2 ; 3 2 3])

a=
-0.285714     	0.714286     	-0.285714     
0.428571     	0.428571     	-0.571429     
0     	-1     	1     

Listing 2.23 Przykład wyznaczania macierzy odwrotnej.
Układy równań liniowych
Rozwiązywanie układu równań liniowych oferuje funkcja x = url(A,b), gdzie A to macierz współczynników, a b to macierz wyrazów wolnych. Zapis x=url(A,B) jest równoważny z x=A\B. Macierz współczynników musi być kwadratowa i posiadać taki sam stopień jak liczba wierszy macierzy wyrazów wolnych. Listing 2.23 przedstawia przykład rozwiązania układu równań liniowych. Układ równań rozwiązywany jest dla każdej kolumny macierzy B.
>> A = [ 6 3 7 ; 5 3 2 ; 1 3 8 ]

A=
6     	3     	7     
5     	3     	2     
1     	3     	8     

>> B = [ 1 2 3 4; 3 5 23 2 ; 2 7 4 3 ]

B=
1     	2     	3     	4     
3     	5     	23     	2     
2     	7     	4     	3     

>> x = url(A,B)

x=
-0.269231     	-1.07692     	-0.961538     	0.269231     
1.67949     	3.71795     	11.8077     	-0.0128205     
-0.346154     	-0.384615     	-3.80769     	0.346154     

>> x=A\B

x=
-0.269231     	-1.07692     	-0.961538     	0.269231     
1.67949     	3.71795     	11.8077     	-0.0128205     
-0.346154     	-0.384615     	-3.80769     	0.346154     

Listing 2.24 Rozwiązywanie układów równań liniowych.
Rozkład LU
Do rozkładu LU macierzy służy funkcja lu(A). Jej działanie różni się w zależności od liczby parametrów wyjściowych.
Wywołanie Y=lu(A) zwraca macierz Y, która dla A, składa się w dolnej części z macierzy L bez elementów na głównej przekątnej i w górnej części z macierzy U (listing 2.24).
>> Y = lu([4 3 2; 9 4 3 ; 2 8 6])

Y=
9     	4     	3     
0.222222     	7.11111     	5.33333     
0.444444     	0.171875     	-0.25     

Listing 2.25 Wywołanie funkcji lu z jednym parametrem wyjściowym.
Wywołanie [L,U]=lu(A)zwraca górną macierz trójkątną w U i trójkątną macierz dolną w L (listing 2.25). Macierz L podana jest odpowiednim permutacjom, tak żeby A=L*U.
>> [L,U] = lu([4 3 2; 9 4 3 ; 2 8 6])

L=
0.444444     	0.171875     	1     
1     	0     	0     
0.222222     	1     	0     


U=
9     	4     	3     
0     	7.11111     	5.33333     
0     	0     	-0.25     

Listing 2.26 Przykład wywołania funkcji lu z dwoma parametrami wyjściowymi.
Wywołania [L,U,P]=lu(A) zwraca trójkątną macierz dolną w L, trójkątną macierz górną w U oraz macierz permutacji w P (listing 2.26). Macierze te spełniają równość L*U=P*A.
>> [L,U,P] = lu([4 3 2; 9 4 3 ; 2 8 6])

L=
1     	0     	0     
0.222222     	1     	0     
0.444444     	0.171875     	1     


U=
9     	4     	3     
0     	7.11111     	5.33333     
0     	0     	-0.25     


P=
0     	1     	0     
0     	0     	1     
1     	0     	0     

Listing 2.27 Przykład wywołania funkcji lu z trzema parametrami wyjściowymi.
Badanie rozmiaru i kształtu zmiennych
Stworzony program posiada szereg wbudowanych funkcji służących do badania rozmiarów i kształtu macierzy. Metody te przedstawione zostały w poniższej tabeli (2.7).
Tabela 2.7 Lista wbudowanych funkcji służących do badania rozmiarów i kształtu zmiennych.
Nazwa funkcji	Opis
size(A)	Funkcja zwraca liczbę wierszy i kolumn A w postaci dwuelementowego wektora.
length(A)	Funkcja zwraca długość największego wymiaru  A.
numel(A)	Zwraca ilość elementów w A.
iscolumn(A)	Zwraca wartość 1, jeżeli A jest wektorem kolumnowym (posiada tylko jedną kolumnę) i 0 w przeciwnym wypadku.
isrow(A)	Zwraca wartość 1, jeżeli A jest wektorem wierszowym (posiada tylko jeden wiersz) i 0 w przeciwnym wypadku.
isempty(A)	Zwraca wartość 1, jeżeli liczba wierszy lub kolumn jest równa 0.
isscalar(A)	Zwraca wartość 1, jeżeli A jest skalarem lub macierzą o wymiarach 1x1.
isvector(A)	Zwraca wartość 1, jeżeli A jest wektorem kolumnowym lub wierszowym.

Wizualizacja danych
Program umożliwia wizualizacje wyników obliczeń w postaci wykresów dwu i trzy wymiarowych. Każda z funkcji służących do rysowania wykresów nie zwraca żadnej wartości. Danymi wejściowymi powinny być wektory wierszowe o takiej samej długości. Wykonywanie obliczeń jest wstrzymane do momentu zamknięcie okna z wykresem.
Dwuwymiarowy wykres liniowy
Metoda plot(x,y) rysuje liniowy wykres funkcji y=f(x). Skala dla osi odciętych i rzędnych jest dobierana automatycznie. Poniższy przykład przedstawia sposób użycia funkcji plot (listing 2.28).
>> x = -10:0.1:10;

>> plot(x,sin(x));
Listing 2.28 Przykład użycia programu do narysowania sinusoidy.
	Polecenia z powyższego listingu służą do narysowania dwuwymiarowego wykresu sinusoidy o argumentach z przedziału -10 do 10 . Wynik poleceń z przykładu został przedstawiony poniżej (rys. 2.12).
 
Rysunek 2.12 Wykres sinusoidy narysowany za pomocą stworzonego programu.
Trójwymiarowy wykres liniowy
Metoda plot3(x,y,z) służy do rysowania trójwymiarowych wykresów liniowych. Wektory x, y, z określają współrzędne punktów w przestrzeni.
t = 0 : 0.1 : 10*3.14;
x = sin(t);
y = cos(t);
plot3(x,y,t);
Listing 2.29 Polecenia służące do rysowania wykresu helisy.
	Polecenia z powyższego przykładu (listing 2.29) służą do narysowania trójwymiarowego wykresu helisy. Wynik jest widoczny poniżej (rys. 2.13).
 
Rysunek 2.13 Wykres helisy stworzony za pomocą programu KLab.
Rysowanie powierzchni
Rysowanie trójwymiarowych powierzchni jest możliwe za pomocą metody mesh(x,y,z), która rysuje wykres funkcji z=f(x,y). Argumenty x, y, z muszą mieć takie same rozmiary.
eps= 2.2204e-16;
temp = -8:0.5:8;
[m,n]=size(temp);
x=[];
y=[];
for i=1:n
	x(i,:) = temp;
	y(:,i) = temp;
end
R = (x.^2 + y.^2).^0.5 + eps;
Z = sin(R)./R;
mesh(x,y,Z);
Listing 2.30 Przykłady skrypt rysujący wykres powierzchniowy.
Powyższy listing (2.30) przedstawia przykładowy skrypt rysujący powierzchnię. Poniżej przedstawiony został wynik jego działania (rys. 2.14).
 
Rysunek 2.14 Wykres powierzchniowy stworzony za pomocą omawianego programu.
Pliki skryptowe
Stworzony program umożliwia zapisanie ciągu poleceń do pliku tekstowego o rozszerzeniu „.m”.	Wykrywane są wszystkie pliki skryptowe umieszczone w aktualnym katalogu roboczym. Zapisany skrypt można uruchomić z poziomu edytora skryptów lub wpisując w linii poleceń nazwę skryptu bez jego rozszerzenia. Skrypty działają na zmiennych zapisanych w głównej przestrzeni roboczej programu.
Zewnętrzne funkcje
W stworzonym programie możliwe jest definiowanie własnych funkcji zapisanych w plikach skryptowych o rozszerzaniu „.m”. Podobnie jak funkcje wbudowane przyjmują one argumenty wejściowe i zwracają wyniki.
W przeciwieństwie do skryptów zewnętrzne funkcje nie mają dostępu do zmiennych zapisanych w głównej przestrzeni roboczej programu i operują na własnej lokalnej przestrzeni roboczej, która przestaje istnieć w momencie zakończenia metody.
Definicja funkcji
Definicja zewnętrznej funkcji musi mieć przedstawioną poniżej (listing 2.31) postać:
% Opcjonalny komentarz
function [ out1, … , outN ] = fun_name ( arg1, … ,argN )
    % ciało funkcji
end % lub endfunction
Listing 2.31 Ogólna postać definicji funkcji zewnętrznej.
Plik zawierający definicję funkcji, powinien rozpoczynać się od słowa kluczowego function, które może być opcjonalnie poprzedzone komentarzem. 
Po słówku kluczowym function występuje lista parametrów wyjściowych, objętych w nawiasy kwadratowe. W przypadku pojedynczej wartości wyjściowej nawiasy mogą zostać pominięte. 
Następnie w definicji powinna znaleźć się nazwa funkcji poprzedzona znakiem =. Nazwa metody musi być taka sama jak nazwa pliku. Po nazwie występuje lista argumentów wejściowych objętych w nawiasy okrągłe.
Ciało funkcji może się składać z dowolnej liczby instrukcji zakończonych słowem kluczowym end lub endfunction.
Poniższy przykład z listingu 2.32 przedstawia definicję funkcji create, zwracającej macierz A o wymiarach określonych przez argumenty wejściowe m i n. 
% plik "create.m"
function A = create(m,n)
	A = rand(m,n)
endfunction
Listing 2.32 Przykład definicji zewnętrznej funkcji create.
Argumenty funkcji
Argumenty wejściowe przekazywane są przez wartość, co oznacza że do funkcji przekazywana jest ich kopia. Jakiekolwiek modyfikacje wewnątrz metody, są więc dokonywane na kopii tych argumentów.
W wywołaniu funkcji można pominąć ostatnie argumenty, jeżeli wiadomo że nie zostaną one użyte we wnętrzu metody. Jeżeli w funkcji nastąpi próba użycia argumentu, który tak naprawdę nie został przekazany, zostanie wyświetlony odpowiedni komunikat o błędzie.
Aby uniknąć kopiowania dużych macierzy podczas wywołania funkcji, można użyć metody eval(‘wyrazenie’), która przyjmuje jako argument wyrażenie zawarte w łańcuchu tekstowym i zwraca jego wynik. Wyrażenie to musi zawierać pojedynczą instrukcje bez operatora przypisania.
% plik “my_size.m”
function [m,n] = my_size( expr )
	[n,m] = size(eval(expr));
end

% linia poleceń
>> [m,n]=my_size('rand(100,300);')

m=
100     

n=
300     

Listing 2.33 Przykład użycia funkcji eval.
W powyższym przykładzie (listing 2.33)  do funkcji my_size przekazany został jedynie łańcuch tekstowy, a stworzenie macierzy odbyło się dopiero w ciele funkcji. Uniknięto dzięki temu niepotrzebnego kopiowania wartości zajmującej stosunkowo dużo pamięci.
Komentarze
Program umożliwia komentowanie wprowadzonych poleceń. Komentarze są ignorowane przez interpreter. Komentarz liniowy rozpoczyna się od znacznika % lub // i trwa do końca linii. Komentarz blokowy może obejmować wiele linii i jest zawarty pomiędzy parą znaczników %{ i %}.  Przykład użycia komentarzy w stworzonym programie został przedstawiony poniżej (rys. 2.15).
 
Rysunek 2.15 Przykład użycia komentarzy
Sterowanie przebiegiem programu
Instrukcja warunkowa IF
Instrukcja warunkowa if pozwala na wykonanie wybranego fragmentu kodu w zależności od warunku. Wyrażenie warunkowe if może mieć jedną z następujących postaci:
Tabela 2.8 Możliwe postacie instrukcji warunkowej if.
if wyrażenie
   instrukcja
end	if wyrażenie
   instrukcja1
else
   instrukcja2
end	if wyrażenie1
   instrukcja1
elseif wyrazenie2
   instrukcja2
else
   instrukcja3
end

Jeżeli wynikiem wyrażenia stanowiącego warunek instrukcji if jest macierz, to warunek jest spełniony jedynie wtedy, gdy wszystkie komórki tej macierzy są różne od 0. Możliwe jest także tworzenie zagnieżdżonych instrukcji if. Przykład użycia instrukcji if do wyznaczenia wartości minimalnej dwóch liczb przedstawiony został poniżej (listing 2.34).
function y = max(a,b)
	if a>b
		y=a;
	else
		y=b;
	endif
endfunction
Listing 2.34 Przykład użycia instrukcji if.
Pętla WHILE
W stworzonym programie możliwe jest użycie pętli while. Musi mieć ona następującą postać:
while wyrażenie
   instrukcja
end
Listing 2.35 Ogólna postać pętli while.
Fragment kodu w pętli jest wykonane dopóki wyrażenie warunkowe jest prawdziwe. Poniższy przykład (listing 2.36) przedstawia użycie pętli while do sortowania elementów poszczególnych wierszy macierzy.
function A = sortuj(A)
 [m,n]=size(A);
 i=1;
 while i<=m		%dla każdego wiersz A wykonuj
     j=2;
     while j<=n
     if A(i,j-1)>A(i,j)
        temp = A(i,j);
        A(i,j) = A(i,j-1);
        A(i,j-1)= temp;
        if j>2
          j=j-1;
        end
     else
        j=j+1;
     end
  end
  i=i+1;
 end
end
Listing 2.36 Przykład użycia pętli while do sortowania liczb.
Pętla FOR
Pętla for umożliwia powtarzanie wybranego zestawu instrukcji określoną liczbę razy. Musi ona mieć następującą postać:
for iterator = macierz_wartości
   instrukcja
end
Listing 2.37 Ogólna postać pętli for
Przy każdym kroku wykonywanie pętli do zmiennej iterator przypisywana jest kolejna kolumna macierzy wartości. Przykład użycia pętli for do tworzenia nowej macierzy przedstawia poniższy listing.
function [A] = create(m,n)
	A=[];
	j=1;
	for i = 1 : m : m*n
		A(:,j) = i:i+m-1;
		j=j+1;
	end
endfunction
Listing 2.38 Przykład użycia pętli for do tworzenia nowej macierzy.
	Słowa kluczowe break, continue i return
Słowo kluczowe break służy do całkowitego przerwania aktualnie wykonywanej pętli. Instrukcja continue powoduje przerwanie jedynie aktualnej iteracji pętli i przejście do następnej. Przerwanie wykonywania funkcji lub skryptu możliwe jest za pomocą instrukcji return. Przykład użycia tych instrukcji został przedstawiony poniżej.
i=1;
while 1
	i*-1;
	for k=i:i+10
		if mod(k,3)==0
			k
		elseif k>i+5
			break
		else
			continue
		end
	end
	if i*-1 < -20
		break;
	end
end
Listing 2.39 Przykład użycia instrukcji break i continue.
 
